{"version":3,"sources":["../../src/cli/index.ts","../../src/cli/commands/analyze.ts","../../src/core/resolver/doh.ts","../../src/core/resolver/cache.ts","../../src/core/net/ip.ts","../../src/core/schema/analyze.ts","../../src/core/output/json.ts","../../src/core/audit/audit.ts","../../src/cli/commands/import.ts","../../src/core/parsers/detect.ts","../../src/core/parsers/provider-detect.ts","../../src/core/parsers/cloudflare.ts","../../src/core/parsers/route53.ts","../../src/core/parsers/generic.ts","../../src/core/parsers/errors.ts","../../src/core/config/schema.ts","../../src/cli/commands/list.ts","../../src/cli/commands/export.ts","../../src/core/output/csv.ts","../../src/core/output/xlsx.ts","../../src/cli/commands/ruleset.ts","../../src/cli/commands/annotate.ts","../../src/cli/commands/echo.ts"],"sourcesContent":["import { Command } from 'commander';\nimport ora from 'ora';\nimport { registerAnalyzeCommand } from './commands/analyze.js';\nimport { registerImportCommand } from './commands/import.js';\nimport { registerListCommand } from './commands/list.js';\nimport { registerExportCommand } from './commands/export.js';\nimport { registerRulesetCommand } from './commands/ruleset.js';\nimport { registerAnnotateCommand } from './commands/annotate.js';\nimport { registerEchoCommand } from './commands/echo.js';\n\nconst program = new Command();\n\nprogram\n  .name('dnsweeper')\n  .description('DNSweeper CLI')\n  .version('0.0.0');\n\n// Attach commands\nregisterAnalyzeCommand(program);\nregisterImportCommand(program);\nregisterListCommand(program);\nregisterExportCommand(program);\nregisterRulesetCommand(program);\nregisterAnnotateCommand(program);\nregisterEchoCommand(program);\n\nasync function main() {\n  const spinner = ora({ text: 'Bootstrapping CLI...', isEnabled: true }).start();\n  spinner.stop();\n  await program.parseAsync(process.argv);\n}\n\nmain().catch((err) => {\n  // eslint-disable-next-line no-console\n  console.error(err);\n  process.exit(1);\n});\n","import { Command } from 'commander';\nimport fs from 'node:fs';\nimport Papa from 'papaparse';\nimport pLimit from 'p-limit';\nimport { fetch } from 'undici';\nimport { resolveDoh, getDohStats, resetDohStats, QType } from '../../core/resolver/doh.js';\nimport { isPrivateIPv4, isPrivateIPv6, isSpecialIPv4, mightBePrivateName } from '../../core/net/ip.js';\nimport { validateAnalyzeArray } from '../../core/schema/analyze.js';\nimport { writeJson } from '../../core/output/json.js';\nimport { appendAudit, sha256File, getRulesetVersion } from '../../core/audit/audit.js';\n\ntype AnalyzeOptions = {\n  httpCheck?: boolean;\n  concurrency?: number;\n  timeout?: number; // ms per probe\n  summary?: boolean; // print risk summary\n  output?: string; // write JSON result file\n  pretty?: boolean; // pretty JSON output\n  includeOriginal?: boolean; // include original row\n  quiet?: boolean; // suppress progress\n  doh?: boolean; // enable DoH resolution\n  dohEndpoint?: string; // custom endpoint\n  dnsType?: string; // single or comma-separated list\n  dnsTimeout?: number;\n  dnsRetries?: number;\n  allowPrivate?: boolean;\n  qps?: number;\n  userAgent?: string;\n};\n\ntype RiskLevel = 'low' | 'medium' | 'high';\n\nfunction pickDomain(row: Record<string, unknown>): string | null {\n  const keys = Object.keys(row).map((k) => k.toLowerCase());\n  const map: Record<string, string> = {};\n  for (const k of Object.keys(row)) map[k.toLowerCase()] = k;\n  const candidates = ['domain', 'host', 'hostname', 'name'];\n  for (const c of candidates) {\n    if (keys.includes(c)) {\n      const raw = String((row as Record<string, unknown>)[map[c]] ?? '').trim();\n      return raw || null;\n    }\n  }\n  return null;\n}\n\nasync function probeOnce(url: string, timeoutMs: number, userAgent?: string): Promise<{ ok: boolean; status?: number }> {\n  const ac = new AbortController();\n  const t = setTimeout(() => ac.abort(), timeoutMs);\n  try {\n    const res = await fetch(url, {\n      method: 'GET',\n      redirect: 'manual',\n      signal: ac.signal,\n      headers: userAgent ? { 'user-agent': userAgent } : undefined,\n    });\n    return { ok: res.status < 400, status: res.status };\n  } catch {\n    return { ok: false };\n  } finally {\n    clearTimeout(t);\n  }\n}\n\nasync function probeDomain(domain: string, timeoutMs: number, userAgent?: string) {\n  const https = await probeOnce(`https://${domain}/`, timeoutMs, userAgent);\n  let http: { ok: boolean; status?: number } = { ok: false };\n  if (!https.ok) {\n    http = await probeOnce(`http://${domain}/`, timeoutMs, userAgent);\n  }\n  const risk: RiskLevel = https.ok ? 'low' : http.ok ? 'medium' : 'high';\n  return { https, http, risk };\n}\n\nexport function registerAnalyzeCommand(program: Command) {\n  program\n    .command('analyze')\n    .argument('<input>', 'input CSV/JSON path')\n    .option('--http-check', 'enable HTTP probing')\n    .option('-c, --concurrency <n>', 'max concurrent probes', (v) => parseInt(String(v), 10), 5)\n    .option('-t, --timeout <ms>', 'per-request timeout (ms)', (v) => parseInt(String(v), 10), 5000)\n    .option('--summary', 'print risk summary (with --http-check)', false)\n    .option('--doh', 'enable DNS over HTTPS resolution', false)\n    .option('--doh-endpoint <url>', 'DoH endpoint (default: https://dns.google/resolve)')\n    .option('--dns-type <type>', 'QTYPE(s): A|AAAA|CNAME|TXT|SRV|CAA|MX|NS|PTR (comma-separated supported)', 'A')\n    .option('--dns-timeout <ms>', 'DNS timeout (ms)', (v) => parseInt(String(v), 10), 3000)\n    .option('--dns-retries <n>', 'DNS retries', (v) => parseInt(String(v), 10), 2)\n    .option('--allow-private', 'allow probing private/special domains or IPs', false)\n    .option('--qps <n>', 'overall queries per second limit', (v) => parseInt(String(v), 10), 0)\n    .option('--user-agent <ua>', 'override HTTP User-Agent header')\n    .option('--quiet', 'suppress periodic progress output', false)\n    .option('-o, --output <file>', 'write analyzed JSON (array)')\n    .option('--pretty', 'pretty-print JSON (with --output)', false)\n    .option('--include-original', 'include original CSV row in output objects', false)\n    .description('Analyze CSV and print data row count (header excluded)')\n    .action(async (input: string, options: AnalyzeOptions) => {\n      try {\n        const fileStream = fs.createReadStream(input, { encoding: 'utf8' });\n        let rows = 0;\n        const domains: string[] = [];\n        const originals: Record<string, unknown>[] = [];\n\n        const papaStream = Papa.parse(Papa.NODE_STREAM_INPUT, {\n          header: true,\n          skipEmptyLines: true,\n        }) as unknown as NodeJS.ReadWriteStream;\n\n        papaStream.on('data', (row: unknown) => {\n          rows += 1;\n          if (options?.httpCheck || options?.doh) {\n            const d = pickDomain((row || {}) as Record<string, unknown>);\n            if (d) domains.push(d);\n          }\n          if (options?.includeOriginal) {\n            originals.push((row || {}) as Record<string, unknown>);\n          }\n        });\n\n        await new Promise<void>((resolve, reject) => {\n          fileStream.on('error', reject);\n          papaStream.on('error', reject);\n          papaStream.on('finish', () => resolve());\n          fileStream.pipe(papaStream);\n        });\n\n        let summary: { low: number; medium: number; high: number } | null = null;\n        const execId = Math.random().toString(36).slice(2, 10);\n        const results: Array<{\n          domain: string;\n          risk?: RiskLevel;\n          https?: { ok: boolean; status?: number };\n          http?: { ok: boolean; status?: number };\n          dns?: {\n            status: string;\n            chain: Array<{ type: string; data: string; ttl?: number }>;\n            elapsedMs: number;\n            queries?: Array<{ type: string; status: string; elapsedMs: number; answers: number }>;\n          };\n          original?: Record<string, unknown>;\n        }> = [];\n        const startedAt = Date.now();\n        let processed = 0;\n        let failed = 0;\n        let sumLatency = 0;\n        let progressTimer: NodeJS.Timeout | null = null;\n\n        const printProgress = () => {\n          const elapsed = (Date.now() - startedAt) / 1000;\n          const qps = elapsed > 0 ? processed / elapsed : 0;\n          const avg = processed > 0 ? sumLatency / processed : 0;\n          const remain = Math.max(0, domains.length - processed);\n          const eta = qps > 0 ? remain / qps : 0;\n          if (!options.quiet) {\n            // print to stderr to avoid polluting stdout\n            console.error(\n              `[progress] ${processed}/${domains.length} qps=${qps.toFixed(2)} avg_ms=${avg.toFixed(\n                0\n              )} fails=${failed} eta_s=${eta.toFixed(0)}`\n            );\n          }\n        };\n\n        if (options?.httpCheck || options?.doh) {\n          const limit = pLimit(Math.max(1, options.concurrency ?? 5));\n          let low = 0, medium = 0, high = 0;\n          if (!options.quiet && domains.length > 0) {\n            progressTimer = setInterval(printProgress, 1000);\n          }\n          if (options.doh) resetDohStats();\n          // QPS limiter\n          const qps = Math.max(0, options.qps ?? 0);\n          let nextAt = Date.now();\n          const gate = async () => {\n            if (qps <= 0) return;\n            const interval = 1000 / qps;\n            const now = Date.now();\n            const wait = Math.max(0, nextAt - now);\n            nextAt = (wait ? nextAt : now) + interval;\n            if (wait > 0) await new Promise((r) => setTimeout(r, wait));\n          };\n          const recent: boolean[] = [];\n          await Promise.all(\n            domains.map((domain, idx) =>\n              limit(async () => {\n                const t0 = Date.now();\n                await gate();\n                // Run DoH and HTTP probing in parallel if both enabled\n                const qname = domain.endsWith('.') ? domain : `${domain}.`;\n                const dnsTypes = String(options.dnsType || 'A')\n                  .split(',')\n                  .map((s) => s.trim().toUpperCase())\n                  .filter(Boolean) as QType[];\n                const pDns = options.doh\n                  ? Promise.all(\n                      dnsTypes.map((qt) =>\n                        resolveDoh(qname, qt, {\n                          dohEndpoint: options.dohEndpoint,\n                          timeoutMs: options.dnsTimeout,\n                          retries: options.dnsRetries,\n                          cd: true,\n                        })\n                      )\n                    )\n                  : Promise.resolve([]);\n                const pHttp = options.httpCheck\n                  ? probeDomain(domain, options.timeout ?? 5000, options.userAgent)\n                  : Promise.resolve({ https: { ok: false }, http: { ok: false }, risk: 'low' as RiskLevel });\n\n                const [rrList, probed] = (await Promise.all([pDns, pHttp])) as [\n                  Array<{ status: string; chain: Array<{ type: string; data: string; ttl?: number }>; elapsedMs: number; qtype?: string }>,\n                  { https: { ok: boolean; status?: number }; http: { ok: boolean; status?: number }; risk: RiskLevel }\n                ];\n\n                let dnsResult:\n                  | {\n                      status: string;\n                      chain: Array<{ type: string; data: string; ttl?: number }>;\n                      elapsedMs: number;\n                      queries?: Array<{ type: string; status: string; elapsedMs: number; answers: number }>;\n                    }\n                  | undefined;\n                if (options.doh) {\n                  // Aggregate multiple qtypes: prefer NOERROR if any; else TIMEOUT/SERVFAIL -> medium; all NXDOMAIN -> high-ish\n                  const queries = rrList.map((r, i) => ({\n                    type: dnsTypes[i] as string,\n                    status: r.status,\n                    elapsedMs: r.elapsedMs,\n                    answers: r.chain?.length || 0,\n                  }));\n                  const anyNoError = rrList.some((r) => r.status === 'NOERROR');\n                  const anyTimeout = rrList.some((r) => r.status === 'TIMEOUT');\n                  const anyServfail = rrList.some((r) => r.status === 'SERVFAIL');\n                  const allNx = rrList.length > 0 && rrList.every((r) => r.status === 'NXDOMAIN');\n                  const status = anyNoError ? 'NOERROR' : allNx ? 'NXDOMAIN' : anyTimeout ? 'TIMEOUT' : anyServfail ? 'SERVFAIL' : 'SERVFAIL';\n                  const chain = rrList.flatMap((r) => r.chain || []);\n                  const elapsedMs = rrList.reduce((sum, r) => sum + (r.elapsedMs || 0), 0);\n                  dnsResult = { status, chain, elapsedMs, queries };\n                }\n                // Private/special filters\n                let skipped = false;\n                let skipReason: string | undefined;\n                if (!options.allowPrivate) {\n                  const privateName = domain ? mightBePrivateName(domain) : false;\n                  const privateIP = (rrList || []).some((r) =>\n                    (r.chain || []).some((h) =>\n                      (h.type === 'A' && (isPrivateIPv4(h.data) || isSpecialIPv4(h.data))) ||\n                      (h.type === 'AAAA' && isPrivateIPv6(h.data))\n                    )\n                  );\n                  if (privateName || privateIP) {\n                    skipped = true;\n                    skipReason = privateName ? 'private-name' : 'private-ip';\n                  }\n                }\n\n                const dt = Date.now() - t0;\n                sumLatency += dt;\n                processed += 1;\n                if (options.httpCheck && !skipped && !probed.https.ok && !probed.http.ok) failed += 1;\n\n                // Combine risk\n                let risk: RiskLevel = probed.risk;\n                if (options.doh && dnsResult) {\n                  if (dnsResult.status === 'NOERROR') {\n                    // keep HTTP-based risk\n                  } else if (dnsResult.status === 'NXDOMAIN') {\n                    // If querying multiple types, NXDOMAIN across all -> high\n                    risk = 'high';\n                  } else if (dnsResult.status === 'TIMEOUT' || dnsResult.status === 'SERVFAIL') {\n                    risk = risk === 'high' ? 'high' : 'medium';\n                  }\n                }\n                if (skipped) {\n                  if (!options.doh || (dnsResult && dnsResult.status === 'NOERROR')) risk = 'low';\n                }\n                if (risk === 'low') low += 1;\n                else if (risk === 'medium') medium += 1;\n                else high += 1;\n                results[idx] = {\n                  domain,\n                  risk,\n                  https: skipped ? undefined : probed.https,\n                  http: skipped ? undefined : probed.http,\n                  dns: dnsResult,\n                  original: options.includeOriginal ? originals[idx] : undefined,\n                  ...(skipped ? { skipped: true, skipReason } : {}),\n                };\n                // Failure spike backoff: if recent 10 have >70% failures, pause briefly\n                recent.push(options.httpCheck ? (!skipped && !probed.https.ok && !probed.http.ok) : false);\n                if (recent.length > 10) recent.shift();\n                const failCount = recent.filter(Boolean).length;\n                if (recent.length >= 10 && failCount / recent.length > 0.7) {\n                  await new Promise((r) => setTimeout(r, 1000));\n                }\n              })\n            )\n          );\n          if (progressTimer) clearInterval(progressTimer);\n          if (!options.quiet && domains.length > 0) printProgress();\n          summary = { low, medium, high };\n          if (!options.quiet) {\n            const elapsed = (Date.now() - startedAt) / 1000;\n            const failRate = processed > 0 ? failed / processed : 0;\n            // eslint-disable-next-line no-console\n            console.error(\n              `[summary] exec=${execId} low=${low} medium=${medium} high=${high} elapsed_s=${elapsed.toFixed(\n                2\n              )} fail_rate=${(failRate * 100).toFixed(1)}%`\n            );\n            if (options.doh) {\n              const s = getDohStats();\n              const total = s.hits + s.misses;\n              const hitRate = total > 0 ? (s.hits / total) * 100 : 0;\n              const avgMiss = s.misses > 0 ? s.timeSpentMs / s.misses : 0;\n              const estSaved = Math.round(s.hits * avgMiss);\n              // eslint-disable-next-line no-console\n              console.error(\n                `[dns] exec=${execId} queries=${total} hits=${s.hits} misses=${s.misses} hit_rate=${hitRate.toFixed(\n                  1\n                )}% time_spent_ms=${s.timeSpentMs} est_saved_ms=${estSaved}`\n              );\n            }\n          }\n          if (options.summary) {\n            // eslint-disable-next-line no-console\n            console.log(`summary=${JSON.stringify(summary)}`);\n          }\n        }\n\n        if (options.output) {\n          if (options.httpCheck || options.doh) {\n            // results already populated in order of domains\n            const pretty = !!options.pretty;\n            const arr = results.filter(Boolean);\n            try {\n              validateAnalyzeArray(arr);\n            } catch (e) {\n              // eslint-disable-next-line no-console\n              console.error('[warn] analyze output schema validation failed:', e);\n            }\n            await writeJson(arr, options.output, pretty);\n            // eslint-disable-next-line no-console\n            console.log(`wrote JSON: ${options.output}`);\n          } else {\n            // Without httpCheck, emit minimal objects with domain if available\n            const out = (originals.length ? originals : domains.map((d) => ({ domain: d }))).map(\n              (r, idx) => ({\n                domain: pickDomain(r as Record<string, unknown>) ?? domains[idx] ?? '',\n                original: options.includeOriginal ? (r as Record<string, unknown>) : undefined,\n              })\n            );\n            await writeJson(out, options.output, !!options.pretty);\n            // eslint-disable-next-line no-console\n            console.log(`wrote JSON: ${options.output}`);\n          }\n        }\n\n        // Audit log (best-effort)\n        try {\n          const inputHash = await sha256File(input);\n          const ruleset = await getRulesetVersion();\n          const auditPath = await appendAudit({\n            cmd: 'analyze',\n            execId,\n            args: { input, httpCheck: !!options.httpCheck, concurrency: options.concurrency, timeout: options.timeout },\n            inputHash,\n            ruleset,\n            rows,\n            summary,\n            node: process.version,\n          });\n          if (!options.quiet) {\n            // eslint-disable-next-line no-console\n            console.error(`[audit] appended -> ${auditPath}`);\n          }\n        } catch {\n          // ignore\n        }\n\n        // Always print row count for compatibility\n        // eslint-disable-next-line no-console\n        console.log(`rows=${rows}`);\n      } catch (e) {\n        const msg = e instanceof Error ? e.message : String(e);\n        // eslint-disable-next-line no-console\n        console.error(msg);\n        process.exit(1);\n      }\n    });\n}\n","import { fetch as undiciFetch } from 'undici';\nimport { getCached, putCached } from './cache.js';\n\nexport type QType = 'A'|'AAAA'|'CNAME'|'TXT'|'SRV'|'CAA'|'MX'|'NS'|'PTR';\n\nexport interface ResolveHop {\n  type: string;\n  data: string;\n  ttl?: number;\n}\n\nexport interface ResolveResult {\n  qname: string;\n  qtype: QType;\n  status: 'NOERROR'|'NXDOMAIN'|'SERVFAIL'|'TIMEOUT';\n  chain: ResolveHop[];\n  ad?: boolean;\n  cd?: boolean;\n  elapsedMs: number;\n}\n\nexport type ResolveOptions = {\n  dohEndpoint?: string; // default to Google DoH\n  timeoutMs?: number; // default 3000\n  retries?: number; // default 2\n  cd?: boolean; // checking disabled\n};\n\nlet customFetch: typeof fetch | null = null;\nexport function setFetch(fn: typeof fetch | null) {\n  customFetch = fn;\n}\n\nconst stats = { hits: 0, misses: 0, timeSpentMs: 0 };\nexport function resetDohStats() {\n  stats.hits = 0;\n  stats.misses = 0;\n  stats.timeSpentMs = 0;\n}\nexport function getDohStats() {\n  return { ...stats };\n}\n\nconst TYPE_MAP: Record<number, QType | string> = {\n  1: 'A', 28: 'AAAA', 5: 'CNAME', 16: 'TXT', 33: 'SRV', 257: 'CAA', 15: 'MX', 2: 'NS', 12: 'PTR',\n};\n\nfunction codeToStatus(code: number): ResolveResult['status'] {\n  if (code === 0) return 'NOERROR';\n  if (code === 3) return 'NXDOMAIN';\n  if (code === 2) return 'SERVFAIL';\n  return 'SERVFAIL';\n}\n\nfunction sleep(ms: number) {\n  return new Promise((r) => setTimeout(r, ms));\n}\n\nfunction jitterDelay(attempt: number) {\n  // base exponential backoff + jitter ~200-1500ms window\n  const base = Math.min(1500, 200 * Math.pow(2, attempt));\n  const jitter = Math.floor(Math.random() * 300);\n  return base + jitter;\n}\n\nexport async function resolveDoh(\n  qname: string,\n  qtype: QType,\n  opts: ResolveOptions = {}\n): Promise<ResolveResult> {\n  const cached = getCached(qname, qtype);\n  if (cached) {\n    stats.hits += 1;\n    return cached;\n  }\n\n  const endpoint = opts.dohEndpoint || 'https://dns.google/resolve';\n  const timeoutMs = opts.timeoutMs ?? 3000;\n  const retries = Math.max(0, opts.retries ?? 2);\n  const cd = opts.cd ?? true;\n\n  const controller = new AbortController();\n  const timer = setTimeout(() => controller.abort(), timeoutMs);\n  const started = Date.now();\n  let lastError: unknown = null;\n\n  for (let attempt = 0; attempt <= retries; attempt++) {\n    try {\n      const u = new URL(endpoint);\n      u.searchParams.set('name', qname);\n      u.searchParams.set('type', qtype);\n      u.searchParams.set('cd', cd ? '1' : '0');\n\n      const res = await (customFetch || (undiciFetch as unknown as typeof fetch))(u.toString(), {\n        method: 'GET',\n        headers: { accept: 'application/dns-json' },\n        signal: controller.signal,\n      });\n      if (!('status' in res) || (res as any).status >= 500) {\n        throw new Error(`http ${(res as any).status}`);\n      }\n      const body = await (res as any).json();\n      const statusCode: number = body.Status;\n      const status = codeToStatus(statusCode);\n      const answers: any[] = Array.isArray(body.Answer) ? body.Answer : [];\n      const chain: ResolveHop[] = answers.map((a) => ({ type: TYPE_MAP[a.type] || String(a.type), data: String(a.data), ttl: a.TTL }));\n      const ttlMin = chain.reduce((min, h) => (typeof h.ttl === 'number' ? Math.min(min, h.ttl) : min), Number.POSITIVE_INFINITY);\n      const elapsedMs = Date.now() - started;\n      const result: ResolveResult = {\n        qname,\n        qtype,\n        status,\n        chain,\n        ad: !!body.AD,\n        cd: !!body.CD,\n        elapsedMs,\n      };\n      if (status === 'NOERROR' && Number.isFinite(ttlMin)) {\n        putCached(qname, qtype, result, ttlMin as number);\n      }\n      stats.misses += 1;\n      stats.timeSpentMs += elapsedMs;\n      clearTimeout(timer);\n      return result;\n    } catch (e) {\n      lastError = e;\n      if (attempt < retries) {\n        await sleep(jitterDelay(attempt));\n        continue;\n      }\n      clearTimeout(timer);\n      const elapsedMs = Date.now() - started;\n      stats.misses += 1;\n      stats.timeSpentMs += elapsedMs;\n      if (e instanceof Error && (e.name === 'AbortError' || /abort/i.test(e.message))) {\n        return { qname, qtype, status: 'TIMEOUT', chain: [], elapsedMs };\n      }\n      return { qname, qtype, status: 'SERVFAIL', chain: [], elapsedMs };\n    }\n  }\n  // Should not reach here\n  const elapsedMs = Date.now() - started;\n  return { qname, qtype, status: 'SERVFAIL', chain: [], elapsedMs };\n}\n","import { ResolveResult } from './doh.js';\n\ntype CacheEntry = { result: ResolveResult; expiresAt: number };\n\nconst store = new Map<string, CacheEntry>();\n\nfunction keyOf(qname: string, qtype: string) {\n  return `${qname}|${qtype}`;\n}\n\nexport function getCached(qname: string, qtype: string): ResolveResult | null {\n  const k = keyOf(qname, qtype);\n  const e = store.get(k);\n  if (!e) return null;\n  if (Date.now() < e.expiresAt) return e.result;\n  store.delete(k);\n  return null;\n}\n\nexport function putCached(qname: string, qtype: string, result: ResolveResult, ttlSec: number) {\n  const expiresAt = Date.now() + Math.max(0, ttlSec) * 1000;\n  store.set(keyOf(qname, qtype), { result, expiresAt });\n}\n\nexport function clearCache() {\n  store.clear();\n}\n\n","// Basic IP utilities for private/special-use detection\nexport function isPrivateIPv4(ip: string): boolean {\n  const m = ip.match(/^([0-9]{1,3})(?:\\.([0-9]{1,3})){3}$/);\n  if (!m) return false;\n  const parts = ip.split('.').map((x) => parseInt(x, 10));\n  if (parts.some((n) => Number.isNaN(n) || n < 0 || n > 255)) return false;\n  const [a, b] = parts;\n  if (a === 10) return true;\n  if (a === 172 && b >= 16 && b <= 31) return true;\n  if (a === 192 && b === 168) return true;\n  if (a === 127) return true; // loopback\n  if (a === 169 && b === 254) return true; // link-local\n  return false;\n}\n\nexport function isSpecialIPv4(ip: string): boolean {\n  // RFC 5735/6890 special ranges (subset)\n  const parts = ip.split('.').map((x) => parseInt(x, 10));\n  if (parts.length !== 4 || parts.some((n) => Number.isNaN(n))) return false;\n  const [a, b] = parts;\n  if (a === 0 || a === 255) return true;\n  if (a === 100 && b >= 64 && b <= 127) return true; // carrier-grade NAT\n  return false;\n}\n\nexport function isPrivateIPv6(ip: string): boolean {\n  // fc00::/7 unique local, fe80::/10 link-local, ::1 loopback\n  const s = ip.toLowerCase();\n  return s.startsWith('fc') || s.startsWith('fd') || s.startsWith('fe80') || s === '::1';\n}\n\nexport function mightBePrivateName(domain: string): boolean {\n  const d = domain.toLowerCase();\n  return d.endsWith('.local') || d.endsWith('.lan') || d.endsWith('.intranet');\n}\n\n","import { z } from 'zod';\n\nexport const HttpSchema = z.object({ ok: z.boolean(), status: z.number().optional() });\nexport const DnsHopSchema = z.object({ type: z.string(), data: z.string(), ttl: z.number().optional() });\nexport const DnsSchema = z.object({\n  status: z.string(),\n  chain: z.array(DnsHopSchema),\n  elapsedMs: z.number(),\n  queries: z\n    .array(z.object({ type: z.string(), status: z.string(), elapsedMs: z.number(), answers: z.number() }))\n    .optional(),\n});\n\nexport const AnalyzeItemSchema = z.object({\n  domain: z.string(),\n  risk: z.enum(['low', 'medium', 'high']).optional(),\n  https: HttpSchema.optional(),\n  http: HttpSchema.optional(),\n  dns: DnsSchema.optional(),\n  original: z.record(z.unknown()).optional(),\n  skipped: z.boolean().optional(),\n  skipReason: z.string().optional(),\n});\n\nexport const AnalyzeArraySchema = z.array(AnalyzeItemSchema);\n\nexport type AnalyzeItem = z.infer<typeof AnalyzeItemSchema>;\n\nexport function validateAnalyzeArray(a: unknown): asserts a is AnalyzeItem[] {\n  AnalyzeArraySchema.parse(a);\n}\n\n","import fs from 'node:fs';\n\nexport async function writeJson(\n  records: unknown[],\n  file: string,\n  pretty = false\n) {\n  const space = pretty ? 2 : 0;\n  const json = JSON.stringify(records, null, space);\n  await fs.promises.writeFile(file, json, 'utf8');\n}\n\n","import fs from 'node:fs';\nimport path from 'node:path';\nimport crypto from 'node:crypto';\n\nexport type AuditEntry = Record<string, unknown>;\n\nfunction defaultAuditPath() {\n  const home = process.env.HOME || process.env.USERPROFILE;\n  if (home) return path.join(home, '.dnsweeper', 'audit.log');\n  return path.join('.tmp', 'audit.log');\n}\n\nasync function ensureDirOf(file: string) {\n  const dir = path.dirname(file);\n  await fs.promises.mkdir(dir, { recursive: true });\n}\n\nexport async function appendAudit(entry: AuditEntry) {\n  const line = JSON.stringify({ ts: new Date().toISOString(), ...entry }) + '\\n';\n  const primary = process.env.DNSWEEPER_AUDIT_PATH || defaultAuditPath();\n  try {\n    await ensureDirOf(primary);\n    // Simple rotation at ~5MB\n    try {\n      const st = await fs.promises.stat(primary);\n      if (st.size > 5 * 1024 * 1024) {\n        const rotated = primary + '.1';\n        await fs.promises.rename(primary, rotated).catch(() => void 0);\n      }\n    } catch {\n      // ignore stat failure\n    }\n    await fs.promises.appendFile(primary, line, 'utf8');\n    return primary;\n  } catch {\n    const fallback = path.join('.tmp', 'audit.log');\n    await ensureDirOf(fallback);\n    await fs.promises.appendFile(fallback, line, 'utf8');\n    return fallback;\n  }\n}\n\nexport async function sha256File(file: string): Promise<string> {\n  return new Promise((resolve, reject) => {\n    const h = crypto.createHash('sha256');\n    const s = fs.createReadStream(file);\n    s.on('error', reject);\n    s.on('data', (chunk) => h.update(chunk));\n    s.on('end', () => resolve(h.digest('hex')));\n  });\n}\n\nexport async function getRulesetVersion(dir = '.tmp/rulesets') {\n  try {\n    const items = await fs.promises.readdir(dir, { withFileTypes: true });\n    const files = items.filter((i) => i.isFile()).map((i) => i.name);\n    let latest = 0;\n    for (const f of files) {\n      const s = await fs.promises.stat(path.join(dir, f));\n      latest = Math.max(latest, s.mtimeMs);\n    }\n    return {\n      count: files.length,\n      latest: latest ? new Date(latest).toISOString() : null,\n    };\n  } catch {\n    return { count: 0, latest: null as string | null };\n  }\n}\n","import { Command } from 'commander';\nimport fs from 'node:fs';\nimport Papa from 'papaparse';\nimport { detectEncoding } from '../../core/parsers/detect.js';\nimport { detectProviderFromHeader, Provider } from '../../core/parsers/provider-detect.js';\nimport { normalizeCloudflare } from '../../core/parsers/cloudflare.js';\nimport { normalizeRoute53 } from '../../core/parsers/route53.js';\nimport { normalizeGeneric } from '../../core/parsers/generic.js';\nimport { writeErrorsCsv, RowError } from '../../core/parsers/errors.js';\nimport { CsvRecord } from '../../types.js';\nimport { loadConfig } from '../../core/config/schema.js';\n\ntype ImportOptions = {\n  output?: string;\n  pretty?: boolean;\n  provider?: Provider;\n  encoding?: string;\n  errors?: string;\n};\n\nexport function registerImportCommand(program: Command) {\n  program\n    .command('import')\n    .argument('<file>', 'input CSV file')\n    .option('-o, --output <file>', 'output JSON file (writes array)')\n    .option('--pretty', 'pretty-print JSON', false)\n    .option('-p, --provider <name>', 'cloudflare|route53|generic (auto if omitted)')\n    .option('-e, --encoding <enc>', 'input encoding (auto if omitted)')\n    .option('--errors <file>', 'write failed rows to CSV', 'errors.csv')\n    .description('Import CSV and normalize to JSON')\n    .action(async (file: string, opts: ImportOptions) => {\n      try {\n        const enc = opts.encoding || (await detectEncoding(file));\n        const fileStream = fs.createReadStream(file, { encoding: enc.startsWith('utf8') ? 'utf8' : 'utf8' });\n        const rows: Record<string, unknown>[] = [];\n        let headerCaptured: string[] | null = null;\n\n        const papaStream = Papa.parse(Papa.NODE_STREAM_INPUT, {\n          header: true,\n          skipEmptyLines: true,\n        }) as unknown as NodeJS.ReadWriteStream;\n\n        papaStream.on('data', (row: unknown) => {\n          const r = row as Record<string, unknown>;\n          if (!headerCaptured) headerCaptured = Object.keys(r);\n          rows.push(r);\n        });\n\n        await new Promise<void>((resolve, reject) => {\n          fileStream.on('error', reject);\n          papaStream.on('error', reject);\n          papaStream.on('finish', () => resolve());\n          fileStream.pipe(papaStream);\n        });\n\n        const cfg = await loadConfig().catch(() => null);\n        const provider: Provider = opts.provider || detectProviderFromHeader(headerCaptured || []);\n        const out: CsvRecord[] = [];\n        const errors: RowError[] = [];\n\n        for (const r of rows) {\n          try {\n            let rec: CsvRecord;\n            switch (provider) {\n              case 'cloudflare':\n                rec = normalizeCloudflare(r);\n                break;\n              case 'route53':\n                rec = normalizeRoute53(r);\n                break;\n              default:\n                rec = normalizeGeneric(r);\n                break;\n            }\n            if (cfg?.defaultTtl && (rec.ttl === undefined || rec.ttl === null)) {\n              rec.ttl = cfg.defaultTtl;\n            }\n            out.push(rec);\n          } catch (e) {\n            const msg = e instanceof Error ? e.message : String(e);\n            errors.push({ error: msg, row: r });\n          }\n        }\n\n        if (opts.errors && errors.length) {\n          await writeErrorsCsv(errors, opts.errors);\n          // eslint-disable-next-line no-console\n          console.error(`errors.csv: wrote ${errors.length} failed rows -> ${opts.errors}`);\n        }\n\n        const space = opts.pretty ? 2 : 0;\n        const json = JSON.stringify(out, null, space);\n        if (opts.output) {\n          await fs.promises.writeFile(opts.output, json, { encoding: 'utf8' });\n          // eslint-disable-next-line no-console\n          console.log(`wrote JSON: ${opts.output}`);\n        } else {\n          // eslint-disable-next-line no-console\n          console.log(json);\n        }\n      } catch (e) {\n        const msg = e instanceof Error ? e.message : String(e);\n        // eslint-disable-next-line no-console\n        console.error(msg);\n        process.exit(1);\n      }\n    });\n}\n","import fs from 'node:fs';\n\nexport type DetectedEncoding = 'utf8' | 'utf8-bom' | 'unknown';\n\nexport async function detectEncoding(file: string): Promise<DetectedEncoding> {\n  const fd = await fs.promises.open(file, 'r');\n  try {\n    const buf = Buffer.alloc(3);\n    const { bytesRead } = await fd.read(buf, 0, 3, 0);\n    if (bytesRead >= 3 && buf[0] === 0xef && buf[1] === 0xbb && buf[2] === 0xbf) return 'utf8-bom';\n    return 'utf8';\n  } finally {\n    await fd.close();\n  }\n}\n\n","export type Provider = 'cloudflare' | 'route53' | 'generic';\n\nexport function detectProviderFromHeader(headers: string[]): Provider {\n  const lower = headers.map((h) => h.trim().toLowerCase());\n  const has = (s: string) => lower.includes(s);\n\n  // Cloudflare: typical headers include: type,name,content,ttl,proxied/proxy status\n  if (has('proxied') || has('proxy status') || (has('type') && has('content') && has('name'))) {\n    return 'cloudflare';\n  }\n\n  // Route53: often has: name,type,ttl,value or alias target\n  if (has('alias target') || has('aliastarget') || (has('value') && has('name') && has('type'))) {\n    return 'route53';\n  }\n\n  return 'generic';\n}\n\n","import { CsvRecord } from '../../types.js';\n\nfunction stripDot(s: string): string {\n  return s.endsWith('.') ? s.slice(0, -1) : s;\n}\n\nexport function normalizeCloudflare(row: Record<string, unknown>): CsvRecord {\n  // Cloudflare exports typically: Type,Name,Content,TTL,Proxied or Proxy Status\n  const map: Record<string, string> = {};\n  for (const k of Object.keys(row)) map[k.toLowerCase()] = k;\n  const get = (k: string) => row[map[k]];\n\n  const type = String(get('type') ?? '').toUpperCase();\n  const name = stripDot(String(get('name') ?? '').trim());\n  const content = String(get('content') ?? '').trim();\n  const ttlRaw = get('ttl');\n  const proxRaw = get('proxied') ?? get('proxy status');\n\n  if (!name || !type) throw new Error('missing name/type');\n  const rec: CsvRecord = { name, type };\n  if (content) rec.content = type === 'TXT' ? content.replace(/^\\\"|\\\"$/g, '') : content;\n  if (ttlRaw !== undefined && ttlRaw !== null && String(ttlRaw).trim() !== '') {\n    const ttl = Number.parseInt(String(ttlRaw), 10);\n    if (Number.isFinite(ttl) && ttl > 0) rec.ttl = ttl;\n    else throw new Error('invalid ttl');\n  }\n  if (proxRaw !== undefined) {\n    const v = String(proxRaw).toLowerCase();\n    if (v === 'true' || v === 'proxied') rec.proxied = true;\n    else if (v === 'false' || v === 'dns only') rec.proxied = false;\n  }\n  if (['A', 'AAAA', 'CNAME', 'TXT'].includes(rec.type) && !rec.content) {\n    throw new Error('missing content');\n  }\n  return rec;\n}\n","import { CsvRecord } from '../../types.js';\n\nfunction stripDot(s: string): string {\n  return s.endsWith('.') ? s.slice(0, -1) : s;\n}\n\nexport function normalizeRoute53(row: Record<string, unknown>): CsvRecord {\n  // Route53 export sample headers include: Name,Type,TTL,Value,Alias Target\n  const map: Record<string, string> = {};\n  for (const k of Object.keys(row)) map[k.toLowerCase()] = k;\n  const get = (k: string) => row[map[k]];\n\n  const type = String(get('type') ?? '').toUpperCase();\n  const name = stripDot(String(get('name') ?? '').trim());\n  const ttlRaw = get('ttl');\n  const value = String(get('value') ?? '').trim();\n  const alias = String((get('alias target') ?? get('aliastarget') ?? '') as string).trim();\n\n  if (!name || !type) throw new Error('missing name/type');\n  const rec: CsvRecord = { name, type };\n  if (alias) rec.aliasTarget = stripDot(alias);\n  if (value) rec.content = type === 'TXT' ? value.replace(/^\\\"|\\\"$/g, '') : value;\n  if (ttlRaw !== undefined && ttlRaw !== null && String(ttlRaw).trim() !== '') {\n    const ttl = Number.parseInt(String(ttlRaw), 10);\n    if (Number.isFinite(ttl) && ttl > 0) rec.ttl = ttl;\n    else throw new Error('invalid ttl');\n  }\n  if (!rec.aliasTarget && ['A', 'AAAA', 'CNAME', 'TXT'].includes(rec.type) && !rec.content) {\n    throw new Error('missing value/alias');\n  }\n  return rec;\n}\n","import { CsvRecord } from '../../types.js';\n\nfunction stripDot(s: string): string {\n  return s.endsWith('.') ? s.slice(0, -1) : s;\n}\n\nexport function normalizeGeneric(row: Record<string, unknown>): CsvRecord {\n  // Expect lower keys: name,type,content,ttl\n  const map: Record<string, string> = {};\n  for (const k of Object.keys(row)) map[k.toLowerCase()] = k;\n  const get = (k: string) => row[map[k]];\n\n  const type = String(get('type') ?? '').toUpperCase();\n  const name = stripDot(String(get('name') ?? '').trim());\n  const content = String(get('content') ?? '').trim();\n  const ttlRaw = get('ttl');\n\n  if (!name || !type) throw new Error('missing name/type');\n  const rec: CsvRecord = { name, type };\n  if (content) rec.content = type === 'TXT' ? content.replace(/^\\\"|\\\"$/g, '') : content;\n  if (ttlRaw !== undefined && ttlRaw !== null && String(ttlRaw).trim() !== '') {\n    const ttl = Number.parseInt(String(ttlRaw), 10);\n    if (Number.isFinite(ttl) && ttl > 0) rec.ttl = ttl;\n    else throw new Error('invalid ttl');\n  }\n  // Basic validation: certain types require content\n  if (['A', 'AAAA', 'CNAME', 'TXT'].includes(rec.type) && !rec.content) {\n    throw new Error('missing content');\n  }\n  return rec;\n}\n","import fs from 'node:fs';\nimport Papa from 'papaparse';\n\nexport type RowError = { error: string; row: Record<string, unknown> };\n\nexport async function writeErrorsCsv(errors: RowError[], file: string) {\n  if (!errors.length) return;\n  const rows = errors.map((e) => ({ ...e.row, error: e.error }));\n  const csv = (Papa as unknown as { unparse: (r: unknown, cfg?: unknown) => string }).unparse(rows, {\n    header: true,\n  });\n  await fs.promises.writeFile(file, csv, 'utf8');\n}\n\n","import fs from 'node:fs';\nimport path from 'node:path';\nimport { z } from 'zod';\n\nexport const ConfigSchema = z.object({\n  // Reserved for future use (M1: read-only placeholder)\n  defaultTtl: z.number().int().positive().optional(),\n});\n\nexport type AppConfig = z.infer<typeof ConfigSchema>;\n\nconst candidates = ['dnsweeper.config.json'];\n\nexport async function loadConfig(cwd = process.cwd()): Promise<AppConfig | null> {\n  for (const f of candidates) {\n    const p = path.join(cwd, f);\n    try {\n      const raw = await fs.promises.readFile(p, 'utf8');\n      const json = JSON.parse(raw);\n      return ConfigSchema.parse(json);\n    } catch {\n      // ignore and continue\n    }\n  }\n  return null;\n}\n\n","ï»¿import { Command } from 'commander';\nimport fs from 'node:fs';\nimport Table from 'cli-table3';\n\ntype Risk = 'low' | 'medium' | 'high';\n\nfunction riskToRank(r: Risk): number {\n  return r === 'low' ? 0 : r === 'medium' ? 1 : 2;\n}\n\nexport function registerListCommand(program: Command) {\n  program\n    .command('list')\n    .argument('<input>', 'input JSON file (array of records with risk)')\n    .option('--min-risk <level>', 'low|medium|high', 'low')\n    .description('List records by minimum risk')\n    .action(async (input: string, opts: { minRisk: Risk }) => {\n      const raw = await fs.promises.readFile(input, 'utf8');\n      const data = JSON.parse(raw);\n      if (!Array.isArray(data)) {\n        throw new Error('input JSON must be an array');\n      }\n      const minRisk = (opts.minRisk || 'low') as Risk;\n      const minRank = riskToRank(minRisk);\n      const records = (data as Record<string, unknown>[]) \n        .filter((r) => ['low', 'medium', 'high'].includes(String((r as any).risk)))\n        .filter((r) => riskToRank((r as any).risk as Risk) >= minRank);\n\n      const table = new Table({ head: ['domain', 'risk'] });\n      for (const r of records) {\n        table.push([String((r as any).domain ?? ''), String((r as any).risk ?? '')]);\n      }\n      // eslint-disable-next-line no-console\n      console.log(table.toString());\n      // eslint-disable-next-line no-console\n      console.log(`count=${records.length}`);\n    });\n}\n","import { Command } from 'commander';\nimport fs from 'node:fs';\nimport { writeJson } from '../../core/output/json.js';\nimport { writeCsv } from '../../core/output/csv.js';\nimport { writeXlsx } from '../../core/output/xlsx.js';\n\ntype ExportOptions = {\n  format: 'json' | 'csv' | 'xlsx';\n  output: string;\n  pretty?: boolean;\n};\n\nexport function registerExportCommand(program: Command) {\n  program\n    .command('export')\n    .argument('<input>', 'input JSON file (array)')\n    .requiredOption('-o, --output <file>', 'output file path')\n    .option('-f, --format <fmt>', 'json|csv|xlsx', 'json')\n    .option('--pretty', 'pretty JSON (when --format=json)', false)\n    .description('Export records to JSON/CSV/XLSX')\n    .action(async (input: string, opts: ExportOptions) => {\n      try {\n        const raw = await fs.promises.readFile(input, 'utf8');\n        const data = JSON.parse(raw);\n        if (!Array.isArray(data)) {\n          throw new Error('input JSON must be an array');\n        }\n        const records = data as Record<string, unknown>[];\n\n        const fmt = (opts.format || 'json').toLowerCase();\n        if (fmt === 'json') {\n          await writeJson(records, opts.output, !!opts.pretty);\n        } else if (fmt === 'csv') {\n          await writeCsv(records, opts.output);\n        } else if (fmt === 'xlsx') {\n          await writeXlsx(records, opts.output);\n        } else {\n          throw new Error(`unsupported format: ${opts.format}`);\n        }\n        // eslint-disable-next-line no-console\n        console.log(`wrote ${fmt}: ${opts.output}`);\n      } catch (e) {\n        const msg = e instanceof Error ? e.message : String(e);\n        // eslint-disable-next-line no-console\n        console.error(msg);\n        process.exit(1);\n      }\n    });\n}\n","import fs from 'node:fs';\nimport Papa from 'papaparse';\n\nfunction normalizeRow(row: Record<string, unknown>): Record<string, unknown> {\n  const out: Record<string, unknown> = {};\n  for (const [k, v] of Object.entries(row)) {\n    if (v === null || v === undefined) {\n      out[k] = '';\n    } else if (typeof v === 'object') {\n      out[k] = JSON.stringify(v);\n    } else {\n      out[k] = v;\n    }\n  }\n  return out;\n}\n\nexport async function writeCsv(records: Record<string, unknown>[], file: string) {\n  const rows = records.map(normalizeRow);\n  const csv = (Papa as unknown as { unparse: (r: unknown, cfg?: unknown) => string }).unparse(\n    rows,\n    { header: true }\n  );\n  await fs.promises.writeFile(file, csv, 'utf8');\n}\n","import ExcelJS from 'exceljs';\n\nfunction collectColumns(records: Record<string, unknown>[]): string[] {\n  const set = new Set<string>();\n  for (const r of records) {\n    for (const k of Object.keys(r)) set.add(k);\n  }\n  return Array.from(set.values());\n}\n\nfunction normalizeCell(v: unknown): string | number | boolean | null {\n  if (v === null || v === undefined) return '';\n  if (typeof v === 'object') return JSON.stringify(v);\n  return v as string | number | boolean;\n}\n\nexport async function writeXlsx(records: Record<string, unknown>[], file: string) {\n  const wb = new ExcelJS.Workbook();\n\n  const hasRisk = records.some((r) => Object.prototype.hasOwnProperty.call(r, 'risk'));\n  if (hasRisk) {\n    // Summary sheet\n    const wsSummary = wb.addWorksheet('Summary');\n    const counts = { low: 0, medium: 0, high: 0 };\n    for (const r of records) {\n      const risk = String((r as any).risk || '');\n      if (risk === 'low') counts.low += 1;\n      else if (risk === 'medium') counts.medium += 1;\n      else if (risk === 'high') counts.high += 1;\n    }\n    wsSummary.columns = [\n      { header: 'risk', key: 'risk' },\n      { header: 'count', key: 'count' },\n    ];\n    wsSummary.addRow({ risk: 'low', count: counts.low });\n    wsSummary.addRow({ risk: 'medium', count: counts.medium });\n    wsSummary.addRow({ risk: 'high', count: counts.high });\n\n    // High sheet\n    const highs = records.filter((r) => String((r as any).risk) === 'high');\n    const colsHigh = collectColumns(highs);\n    const wsHigh = wb.addWorksheet('High');\n    wsHigh.columns = colsHigh.map((k) => ({ header: k, key: k }));\n    for (const r of highs) {\n      const row: Record<string, unknown> = {};\n      for (const c of colsHigh) row[c] = normalizeCell((r as Record<string, unknown>)[c]);\n      wsHigh.addRow(row);\n    }\n\n    // All sheet\n    const colsAll = collectColumns(records);\n    const wsAll = wb.addWorksheet('All');\n    wsAll.columns = colsAll.map((k) => ({ header: k, key: k }));\n    for (const r of records) {\n      const row: Record<string, unknown> = {};\n      for (const c of colsAll) row[c] = normalizeCell((r as Record<string, unknown>)[c]);\n      wsAll.addRow(row);\n    }\n  } else {\n    // Backward compatible single-sheet export\n    const ws = wb.addWorksheet('Export');\n    const columns = collectColumns(records);\n    ws.columns = columns.map((k) => ({ header: k, key: k }));\n    for (const r of records) {\n      const row: Record<string, unknown> = {};\n      for (const c of columns) row[c] = normalizeCell((r as Record<string, unknown>)[c]);\n      ws.addRow(row);\n    }\n  }\n\n  await wb.xlsx.writeFile(file);\n}\n","import { Command } from 'commander';\nimport fs from 'node:fs';\nimport path from 'node:path';\n\nasync function ensureDir(dir: string) {\n  await fs.promises.mkdir(dir, { recursive: true });\n}\n\nasync function listFiles(dir: string) {\n  try {\n    const items = await fs.promises.readdir(dir, { withFileTypes: true });\n    return items.filter((i) => i.isFile()).map((i) => i.name);\n  } catch {\n    return [] as string[];\n  }\n}\n\nexport function registerRulesetCommand(program: Command) {\n  const cmd = program.command('ruleset').description('Manage rulesets');\n\n  cmd\n    .command('list')\n    .option('--dir <path>', 'ruleset directory', '.tmp/rulesets')\n    .description('List available rulesets')\n    .action(async (opts: { dir: string }) => {\n      const dir = opts.dir || '.tmp/rulesets';\n      const files = await listFiles(dir);\n      if (!files.length) {\n        // eslint-disable-next-line no-console\n        console.log('(no rulesets)');\n        return;\n      }\n      // eslint-disable-next-line no-console\n      console.log(files.join('\\n'));\n    });\n\n  cmd\n    .command('add')\n    .argument('<name>', 'ruleset name')\n    .argument('<file>', 'source JSON file')\n    .option('--dir <path>', 'ruleset directory', '.tmp/rulesets')\n    .description('Add a ruleset file by name')\n    .action(async (name: string, file: string, opts: { dir: string }) => {\n      const dir = opts.dir || '.tmp/rulesets';\n      await ensureDir(dir);\n      const dst = path.join(dir, `${name}.json`);\n      const buf = await fs.promises.readFile(file);\n      // Basic validation: ensure JSON parses\n      JSON.parse(buf.toString('utf8'));\n      await fs.promises.writeFile(dst, buf);\n      // eslint-disable-next-line no-console\n      console.log(`added: ${dst}`);\n    });\n\n  cmd\n    .command('version')\n    .option('--dir <path>', 'ruleset directory', '.tmp/rulesets')\n    .description('Show ruleset set version (count + latest mtime)')\n    .action(async (opts: { dir: string }) => {\n      const dir = opts.dir || '.tmp/rulesets';\n      const files = await listFiles(dir);\n      let latest = 0;\n      for (const f of files) {\n        const s = await fs.promises.stat(path.join(dir, f));\n        latest = Math.max(latest, s.mtimeMs);\n      }\n      // eslint-disable-next-line no-console\n      console.log(\n        JSON.stringify(\n          { count: files.length, latest: latest ? new Date(latest).toISOString() : null },\n          null,\n          0\n        )\n      );\n    });\n}\n","import { Command } from 'commander';\nimport fs from 'node:fs';\n\ntype AnnotateOptions = {\n  output?: string;\n  contains?: string;\n  regex?: string;\n  note?: string;\n  label?: string[];\n  pretty?: boolean;\n};\n\nfunction matchDomain(rec: Record<string, unknown>, contains?: string, regex?: RegExp): boolean {\n  const domain = String((rec as any).domain ?? '');\n  if (!domain) return false;\n  if (contains && domain.includes(contains)) return true;\n  if (regex && regex.test(domain)) return true;\n  return !contains && !regex ? true : false;\n}\n\nfunction addLabels(arr: unknown, labels: string[]): string[] {\n  const set = new Set<string>();\n  if (Array.isArray(arr)) {\n    for (const v of arr) if (typeof v === 'string') set.add(v);\n  }\n  for (const l of labels) set.add(l);\n  return Array.from(set.values());\n}\n\nexport function registerAnnotateCommand(program: Command) {\n  program\n    .command('annotate')\n    .argument('<input>', 'input JSON array file')\n    .option('-o, --output <file>', 'output JSON file (writes array)')\n    .option('--contains <text>', 'match domain containing text')\n    .option('--regex <pattern>', 'match domain by JS RegExp (without flags)')\n    .option('--note <text>', 'set or append note')\n    .option('--label <name...>', 'add label(s)')\n    .option('--pretty', 'pretty-print JSON', false)\n    .description('Annotate JSON records with notes/labels by domain filter')\n    .action(async (input: string, opts: AnnotateOptions) => {\n      try {\n        const raw = await fs.promises.readFile(input, 'utf8');\n        const data = JSON.parse(raw);\n        if (!Array.isArray(data)) throw new Error('input JSON must be an array');\n\n        const re = opts.regex ? new RegExp(opts.regex) : undefined;\n        const labels = opts.label || [];\n        let matched = 0;\n\n        const out = (data as Record<string, unknown>[]).map((r) => {\n          if (matchDomain(r, opts.contains, re)) {\n            matched += 1;\n            const next: Record<string, unknown> = { ...r };\n            if (opts.note) {\n              const prev = String((next as any).note ?? '').trim();\n              next.note = prev ? `${prev}; ${opts.note}` : opts.note;\n            }\n            if (labels.length) {\n              next.labels = addLabels((next as any).labels, labels);\n            }\n            return next;\n          }\n          return r;\n        });\n\n        const space = opts.pretty ? 2 : 0;\n        const json = JSON.stringify(out, null, space);\n        if (opts.output) {\n          await fs.promises.writeFile(opts.output, json, 'utf8');\n          // eslint-disable-next-line no-console\n          console.log(`annotated=${matched}, wrote: ${opts.output}`);\n        } else {\n          // eslint-disable-next-line no-console\n          console.log(json);\n        }\n      } catch (e) {\n        const msg = e instanceof Error ? e.message : String(e);\n        // eslint-disable-next-line no-console\n        console.error(msg);\n        process.exit(1);\n      }\n    });\n}\n","import { Command } from 'commander';\n\ntype EchoOptions = {\n  newline: boolean; // commander maps --no-newline to newline=false\n};\n\nexport function registerEchoCommand(program: Command) {\n  program\n    .command('echo')\n    .argument('[text...]', 'text to echo back')\n    .option('-n, --no-newline', 'do not output the trailing newline')\n    .description('Echo arguments back (debug helper)')\n    .action((parts: string[] = [], opts: EchoOptions) => {\n      const out = (parts || []).join(' ');\n      const suffix = opts?.newline === false ? '' : '\\n';\n      // Use stdout.write to control newline behavior precisely\n      process.stdout.write(out + suffix);\n    });\n}\n\n"],"mappings":"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","names":["fs","elapsedMs","fs","candidates","program","fs","fs","Papa","fs","stripDot","stripDot","fs","Papa","fs","path","z","program","fs","Papa","fs","program","fs","fs","Papa","program","fs","fs","path","program","fs","program","program"]}